---
format: typst
---

# Lab 4 Worksheet - Practice

* add something about loading a csv and having to use
# Split the one column into four
energy_raw <- separate(
  energy_raw,
  col = 1,
  into = c("State", "2021", "2022", "2023"),
  sep = ","
)
* make sure str extract is clear str_extract(.x, "\\d+\\.?\\d*")

#### Q1. Extract and clean text patterns from strings using regular expressions.

You are given a messy dataset of energy sources with inconsistent units and spacing.

```{r}
energy_sources <- c("Solar (MWh)", "Wind (GWh)", "Coal (MWh)", "Hydro (kWh)")
```

a.  Use str_detect() to identify all energy sources that contain the substring "Wind" or "Hydro" (hint: use the \| operator in regex).

```{r}
library(tidyverse)
```

```{r}
str_detect(energy_sources, "(Wind .*)|(Hydro .*)")
```

b.  Extract the unit type (e.g., MWh, GWh, kWh) using str_extract(). Make sure your pattern handles extra spaces or hyphens.

```{r}
str_extract(energy_sources, "\\([A-Za-z]{3}\\)")
```

c.  Clean the names to keep only the energy source name, trimming whitespace and removing parentheses.

```{r}
energy_sources_cleaned <- str_extract(energy_sources, "[A-Z][a-z]* ")
energy_sources_cleaned <- sub(" ", "", energy_sources_cleaned)
energy_sources_cleaned
```

d.  Create a clean tibble called energy_clean with two columns: source and unit.

```{r}
energy_unit_cleaned <- str_extract(energy_sources, "\\([A-Za-z]{3}\\)")
energy_unit_cleaned <- sub("\\(", "", energy_unit_cleaned)
energy_unit_cleaned <- sub("\\)", "", energy_unit_cleaned)
energy_clean <- tibble(source = energy_sources_cleaned, unit = energy_unit_cleaned)
```

e.  Discussion: Why might regex cleaning be important before performing joins or aggregations?\
    \

#### Q2. State Datasets: Joins and Pivots

We’ll use built-in datasets to explore US state-level data. state.x77 contains metrics such as population, income, and life expectancy. state.region classifies each state into one of four regions: Northeast, South, North Central, West.

```{r}
# Load datasets
library(dplyr)

# Convert matrix to data frame
states <- data.frame(state.x77)

# Add state names as a new column
states$state <- rownames(states)

# select and reorder columns
states <- states |>
  select(state, Income, Population, Illiteracy)
# table for regions
regions <- data.frame(state = state.name, region = state.region)

states

```

a.  Perform a left join to combine socioeconomic and regional data.

```{r}
left_join(states, regions, by = "state")
```

b.  Perform an inner join. How many rows remain, and why is it the same or different?

```{r}
inner_join(states, regions, by = "state")
```

The dimensions are the same since we have the data from all of the states and both left and inner joins take columns from both of the dataframes.

c.  Perform an anti join to check if any state names don’t match between datasets. What might cause mismatches like this in real projects?

```{r}
anti_join(states, regions, by = "state")
```

There are no mismatches between these two datasets. Different ways the same states are represented in text might lead to mismatch between data.

d.  Discussion: Why would you prefer a left join over an inner join when merging state-level datasets?\
    \
    We might want to keep data from all 50 states instead of only states where we have complete data.


e. Use pivot_longer() to make the socioeconomic data longer.\

```{r}
states |> pivot_longer(cols = -c(state), names_to = "variable", values_to = "statistic")
```

#### Q2.5.

Load this data:

```{r}
library(tidyverse)

# Sample sales data
sales <- tibble(
  Store = c("Store A", "Store B", "Store C"),
  Jan_Sales = c(100, 150, 120),
  Feb_Sales = c(200, 180, 130),
  Mar_Sales = c(150, 200, 140)
)

sales
```

a. Convert the dataset from wide (one column per month) to long (one row per month per store).

```{r}
sales |> pivot_longer(cols = -c(Store), names_to = "month_sales", values_to = "sales_amount")
```

b. Clean month names by removing _Sales.

```{r}
sales |> 
  pivot_longer(cols = -c(Store), names_to = "month_sales", values_to = "sales_amount") |>
  mutate(month_sales = str_remove(month_sales, "_Sales"))
```

c. Convert the long dataset back to wide, with one column per month.

```{r}
sales |> 
  pivot_longer(cols = -c(Store), names_to = "month_sales", values_to = "sales_amount") |>
  mutate(month_sales = str_remove(month_sales, "_Sales")) |>
  pivot_wider(names_from = "month_sales", values_from = "sales_amount")
```

#### Q3. Mapping

Let's visualize data by state.

```{r}
library(ggplot2)
library(maps)
library(dplyr)

us_map <- map_data("state")

state_data <- states |>
  left_join(regions, by = "state") |>
  mutate(state = tolower(state))

```

Use a join to combine the us_map with the state_data

```{r}
us_map_joined <- left_join(state_data, us_map, by = c("state" = "region"))
```

Create a chloropleth map:

```{r}
ggplot(us_map_joined, aes(long, lat, group = group, fill = Income)) +
  geom_polygon(color = "white") +
  coord_fixed(1.3) +
  theme_minimal() +
  scale_fill_viridis_c() +
  labs(title = "Average Income by State")
```

b.  Swap Income for Life Exp to visualize life expectancy instead. Try changing the color scale using scale_fill_gradient() or scale_fill_gradient2()

```{r}
ggplot(us_map_joined, aes(long, lat, group = group, fill = Income)) +
  geom_polygon(color = "white") +
  coord_fixed(1.3) +
  theme_minimal() +
  scale_fill_viridis_c() +
  labs(title = "Average Income by State")
```

#### Q4. Quarto Dashboard Setup

Create a new file ev-dashboard.qmd and add:

```{markdown}

---
title: "EV Power Dashboard"
format: dashboard
---

Add some sections:

### Overview

Your project introduction.

### Map Visualization

# Paste your ggplot map code here

### Data Table

# Show your joined dataset

head(us_map_joined)

Then render:

quarto preview

```